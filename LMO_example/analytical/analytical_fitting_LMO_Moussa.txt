The goal of this exercise is to fit experimental dispersion data from a magnetically ordered system with linear spin-wave theory analytically.  The guiding principle of writing the code was to make the syntax user-friendly and extensible.  It is likely that for the September workshop, a different philosophy of writing the code that uses less helper-abstractions may be more appropriate.  I started with a "stream-of-conciousness" style monolithic code ("LMO_analytical_load_and_plot_data_07302023.jl"), which I then broke down into sections as per the proposed organizational work-flow scheme.  While these examples are only for fitting the dispersion, there are many common abstraction needs and workflows for the problem of fitting S(Q,hw).

REFERENCE: https://journals.aps.org/prb/abstract/10.1103/PhysRevB.54.15149

Assets:
1)	Magnetic structure - The magnetic structure is an A-type antiferromagnet, having the spins along the b-axis of the crystallographic cell.
2)	Experimental data - The data in this exercise were digitized from the reference and consists of scans along three different directions.
3)	Model Hamiltonian - The proposed model is to have two exchanges (Jab in the basal plane and Jc between planes) and one single-ion anisotropy of the lowest order (D).
Workflow:
1)	Input magnetic structure - I have some handwritten notes I'm cleaning up for this.
2)	Check magnetic structure - I have some handwritten notes I'm cleaning up for this.
3)	Input model Hamiltonian - "3_LMO_analytical_InputModelHamiltonian.jl" You will see a bunch of structures and functions that exist to make the syntax easier for the user.  The "job" of the user at this step is to create a function for their analytical dispersion.  I don't remember why I was using SVectors as the outputs for the function, but there was some test case in my coding journey where that was required to be Sunny-similar.
4)	Check model Hamiltonian - "4_LMO_analytical_CheckModelHamiltonian.jl" In this code, the analytical function built in the previous step is plotted with some initial parmaeter values and user-defined q-points to provide a sanity check of the numerics.  At this step, some of the defined abstractions begin to be utilized.  Parameters live in a dictionary.  The AnalyticalModel type is used.  I'm still not convinced with some of the structure ownership organization, but at this step, some of the model is still in an ExpDataGroup type, so the fastest way to visualize simulated data was to work with an "empty experiment".  I introduced the concept of a "direction" for a scan to aid in visualization, and worked only in these examples under the assumption that the momentum scan direction is well defined.
5)	Load experimental data - "5_LMO_analytical_LoadExperimentalData.jl" (Make sure you have the CSV files path correctly defined in the script)  Here, the code introduces the function "load_group" that is currently written only to deal with dispersion data.  A variable "LMO_analytical_data" is instantiated with the "load_group" method to contain all of the experiment.
6)	Check experimental data - "6_LMO_analytical_CheckExperimentalData.jl" Here the code introduces the function "plot_experiment!" that is currently written to deal with dispersion data.  The "direction" is inferred from the experimental data.
7)	Optimize model using experimental data - "7_LMO_analytical_OptimizeModelFromExperiment.jl" Here, the user is introduced to the concepts of optimization flags and parameter bounds.  I have an intermediary script I've not included here that does a brute force check of parameter compatibility with the Hamiltonian.  The functions "refine_model!" and "update_dispersion_and_residuals!" are used for the first time.  It may be smart to introduce an "optimizer" structure (either some Optim.jl built-in or something less verbose to be defined as a helper).  In this example, a bounded search via an L-BFGS is used.  The "dense" data concept is also used here, as for dispersion a guide to the eye between supplied data points can be helpful.
8)	Check optimized model - "8_LMO_analytical_CheckOptimizedModelFromExperiment.jl" On the timeline for September, one accessible check of the optimized solution is to visualize the objective function as maps in parameter space.  This work is on the edge of what I've been trying to do, and I want to do some more error checking of the parameter maps.  Also, I've not yet done a numerical Hessian to get a covariance matrix, but from my understanding this is possible.